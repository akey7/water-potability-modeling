---
title: "Water Potability EDA"
author: "Alicia Key"
date: "2022-08-11"
output: html_document
---

# Water Potability EDA

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(readr)
library(dplyr)
library(tidyr)
library(rsample)
library(parsnip)
library(yardstick)
library(broom)
library(ggplot2)
library(tune)
```

## Load the data and clean it

### Initial load of raw data

```{r}
water <- read_csv("data/water_potability.csv")
knitr::kable(head(water))
```

### Fill NA values

There are a lot of NA values. Let's fix that. Fill all NA values in a column with the median value in that column. Also, lower case all column names.

For the potability column, convert it into a factor with human readable names. For work in tidymodels, the first level of the factor is the event of interest. In this case, the event of interest is potable water.

```{r}
ph_median <- median(water$ph, na.rm = TRUE)
hardness_median <- median(water$Hardness, na.rm = TRUE)
solids_median <- median(water$Solids, na.rm = TRUE)
chloramines_median <- median(water$Chloramines, na.rm = TRUE)
sulfate_median <- median(water$Sulfate, na.rm = TRUE)
conductivity_median <- median(water$Conductivity, na.rm = TRUE)
organic_carbon_median <- median(water$Organic_carbon, na.rm = TRUE)
trihalomethanes_median <- median(water$Trihalomethanes, na.rm = TRUE)
turbidity_median <- median(water$Turbidity, na.rm = TRUE)

water_clean <- water %>%
  replace_na(list(
    ph = ph_median,
    Hardness = hardness_median,
    Solids = solids_median,
    Chloramines = chloramines_median,
    Sulfate = sulfate_median,
    Conductivity = conductivity_median,
    Organic_carbon = organic_carbon_median,
    Trihalomethanes = trihalomethanes_median,
    Turbidity = turbidity_median
  )) %>%
  mutate(
    potability_factor = factor(
      case_when(
        Potability == 1 ~ "potable",
        Potability == 0 ~ "not potable"
      ),
      levels = c("potable", "not potable")
    )
  ) %>%
  select(-Potability)

knitr::kable(head(water_clean))
```

## Exploratory visualization

### Counts of each class

```{r}
class_counts <- tibble(
  potability = c("potable", "not potable"),
  class_count = c(
    sum(water_clean$potability_factor == "potable"),
    sum(water_clean$potability_factor == "not potable")
  )
)

ggplot(class_counts, aes(x = potability, y = class_count)) +
  geom_col() +
  ggtitle("Counts of each class in dataset") +
  ylab("class count")
```

## Classification test

### Train test split

```{r}
water_split <- initial_split(water_clean, prop = 0.75, strata = potability_factor)
```

Number of rows in training set:

```{r}
nrow(water_train)
```

Number of rows in testing set:

```{r}
nrow(water_test)
```

### Create the logistic regression model

```{r}
logistic_model <- logistic_reg() %>%
  set_engine("glm") %>%
  set_mode("classification")
```

### Fit the model

```{r}
logistic_last_fit <- logistic_model %>%
  last_fit(potability_factor ~ ., split = water_split)
```

## Evaluate model performance

### Collect ROC AUC and accuracy metrics.

```{r}
logistic_last_fit %>%
  collect_metrics() %>%
  knitr::kable()
```

### Collect predictions

Collecting predictions allows us to calculate metrics of model performance.

```{r}
logistic_last_fit_results <- logistic_last_fit %>%
  collect_predictions()
```

### Plot ROC curve

```{r}
logistic_last_fit_results %>%
  roc_curve(truth = potability_factor, .pred_potable) %>%
  autoplot()
```

That is bad! Almost like tossing a coin.

### Mosaic plot

```{r}
logistic_last_fit_results %>%
  conf_mat(truth = potability_factor, estimate = .pred_class) %>%
  autoplot(type = "mosaic")
```


