---
title: "Water Potability EDA"
author: "Alicia Key"
date: "2022-08-11"
output: html_document
---

# Water Potability EDA

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(readr)
library(dplyr)
library(tidyr)
library(rsample)
library(parsnip)
library(yardstick)
library(broom)
library(ggplot2)
library(tune)
```

## Load the data and clean it

### Initial load of raw data

```{r}
water <- read_csv("data/water_potability.csv")
knitr::kable(head(water))
```

### Fill NA values

There are a lot of NA values. Let's fix that. Fill all NA values in a column with the median value in that column. Also, lower case all column names.

For the potability column, convert it into a factor with human readable names. For work in tidymodels, the first level of the factor is the event of interest. In this case, the event of interest is potable water.

```{r}
ph_median <- median(water$ph, na.rm = TRUE)
hardness_median <- median(water$Hardness, na.rm = TRUE)
solids_median <- median(water$Solids, na.rm = TRUE)
chloramines_median <- median(water$Chloramines, na.rm = TRUE)
sulfate_median <- median(water$Sulfate, na.rm = TRUE)
conductivity_median <- median(water$Conductivity, na.rm = TRUE)
organic_carbon_median <- median(water$Organic_carbon, na.rm = TRUE)
trihalomethanes_median <- median(water$Trihalomethanes, na.rm = TRUE)
turbidity_median <- median(water$Turbidity, na.rm = TRUE)

water_clean <- water %>%
  replace_na(list(
    ph = ph_median,
    Hardness = hardness_median,
    Solids = solids_median,
    Chloramines = chloramines_median,
    Sulfate = sulfate_median,
    Conductivity = conductivity_median,
    Organic_carbon = organic_carbon_median,
    Trihalomethanes = trihalomethanes_median,
    Turbidity = turbidity_median
  )) %>%
  mutate(
    potability_factor = factor(
      case_when(
        Potability == 1 ~ "potable",
        Potability == 0 ~ "not potable"
      ),
      levels = c("potable", "not potable")
    )
  ) %>%
  select(-Potability)

knitr::kable(head(water_clean))
```

## Exploratory visualization

### Counts of each class

```{r}
class_counts <- tibble(
  potability = c("potable", "not potable"),
  class_count = c(
    sum(water_clean$potability_factor == "potable"),
    sum(water_clean$potability_factor == "not potable")
  )
)

ggplot(class_counts, aes(x = potability, y = class_count)) +
  geom_col() +
  ggtitle("Counts of each class in dataset") +
  ylab("class count")
```

## Classification test

### Train test split

```{r}
water_split <- initial_split(water_clean, prop = 0.75, strata = potability_factor)
```

Number of rows in training set:

```{r}
nrow(water_train)
```

Number of rows in testing set:

```{r}
nrow(water_test)
```

### Create the logistic regression model

```{r}
logistic_model <- logistic_reg() %>%
  set_engine("glm") %>%
  set_mode("classification")
```

### Fit the model

```{r}
logistic_last_fit <- logistic_model %>%
  last_fit(potability_factor ~ ., split = water_split)
```

## Evaluate model performance

### Collect ROC AUC and accuracy metrics.

```{r}
logistic_last_fit %>%
  collect_metrics() %>%
  knitr::kable()
```

### Collect predictions

Collecting predictions allows us to calculate metrics of model performance.

```{r}
logistic_last_fit_results <- logistic_last_fit %>%
  collect_predictions()
```

### Plot ROC curve

```{r}
logistic_last_fit_results %>%
  roc_curve(truth = potability_factor, .pred_potable) %>%
  autoplot()
```

That is bad! Almost like tossing a coin.

### Mosaic plot

```{r}
logistic_last_fit_results %>%
  conf_mat(truth = potability_factor, estimate = .pred_class) %>%
  autoplot(type = "mosaic")
```

The height of section bounded by the "not potable" row and the "not potable" column means the model was good at guessing water samples that were "not potable" correctly, but guessed that almost no samples were potable.

## Next steps

I need to find another way of filling missing values and then try re-running the model.
